"use strict";(self.webpackChunkbeta_BNB_Docs=self.webpackChunkbeta_BNB_Docs||[]).push([[2042],{3905:(t,e,a)=>{a.d(e,{Zo:()=>h,kt:()=>u});var n=a(67294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function o(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?o(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function l(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},o=Object.keys(t);for(n=0;n<o.length;n++)a=o[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)a=o[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var s=n.createContext({}),c=function(t){var e=n.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},h=function(t){var e=c(t.components);return n.createElement(s.Provider,{value:e},t.children)},d="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},p=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,o=t.originalType,s=t.parentName,h=l(t,["components","mdxType","originalType","parentName"]),d=c(a),p=r,u=d["".concat(s,".").concat(p)]||d[p]||m[p]||o;return a?n.createElement(u,i(i({ref:e},h),{},{components:a})):n.createElement(u,i({ref:e},h))}));function u(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=a.length,i=new Array(o);i[0]=p;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l[d]="string"==typeof t?t:r,i[1]=l;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},34132:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const o={sidebar_label:"Build-in System Contracts",sidebar_position:2,hide_table_of_contents:!1},i="Build-in System Contract",l={unversionedId:"learn/system-contract",id:"learn/system-contract",title:"Build-in System Contract",description:"GitHub Implementation link:",source:"@site/docs/learn/system-contract.md",sourceDirName:"learn",slug:"/learn/system-contract",permalink:"/docs/learn/system-contract",draft:!1,editUrl:"https://github.com/bnb-chain/bnb-chain.github.io/blob/master/docs/learn/system-contract.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Build-in System Contracts",sidebar_position:2,hide_table_of_contents:!1},sidebar:"bscSideBar",previous:{title:"Architecture",permalink:"/docs/learn/cross-chain"},next:{title:"BSC Relayer",permalink:"/docs/learn/bsc-relayer"}},s={},c=[{value:"On-Chain Light Client",id:"on-chain-light-client",level:2},{value:"Precompile Contract",id:"precompile-contract",level:3},{value:"Validate Tendermint Header",id:"validate-tendermint-header",level:4},{value:"Validate Merkle Proof",id:"validate-merkle-proof",level:4},{value:"Build-in System Contract",id:"build-in-system-contract-1",level:3},{value:"<strong>Merkle Proof Verification Library</strong>",id:"merkle-proof-verification-library",level:4},{value:"<strong>TokenHub Contract</strong>",id:"tokenhub-contract",level:4},{value:"<strong>TokenManager Contract</strong>",id:"tokenmanager-contract",level:4},{value:"<strong>BSCValidatorSet Contract</strong>",id:"bscvalidatorset-contract",level:4},{value:"<strong>System Reward Contract</strong>",id:"system-reward-contract",level:4},{value:"<strong>Liveness Slash Contract</strong>",id:"liveness-slash-contract",level:4},{value:"<strong>BscValidatorSet Contract</strong>",id:"bscvalidatorset-contract-1",level:4},{value:"<strong>RelayerHub Contract</strong>",id:"relayerhub-contract",level:4},{value:"<strong>Governance Contract</strong>",id:"governance-contract",level:4},{value:"<strong>Cross Chain Contract</strong>",id:"cross-chain-contract",level:4}],h={toc:c},d="wrapper";function m(t){let{components:e,...o}=t;return(0,r.kt)(d,(0,n.Z)({},h,o,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"build-in-system-contract"},"Build-in System Contract"),(0,r.kt)("p",null,"GitHub Implementation link: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/bsc-genesis-contract"},"https://github.com/bnb-chain/bsc-genesis-contract")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Contract Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Contract Address"),(0,r.kt)("th",{parentName:"tr",align:null},"ABI file"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BSCValidatorSet Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001000"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/bscvalidatorset.abi"},"bscvalidatorset"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Liveness Slash Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001001"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/slashindicator.abi"},"slashindicator"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SystemReward Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001002"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/systemreward.abi"},"systemreward"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TendermintLightClient Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001003"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/tendermintlightclient.abi"},"tendermintlightclient"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TokenHub Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001004"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/tokenhub.abi"},"tokenhub"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RelayerIncentivize Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001005"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/relayerincentivize.abi"},"relayerincentivize"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RelayerHub Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001006"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/relayerhub.abi"},"relayerhub"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GovHub Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001007"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/govhub.abi"},"govhub"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TokenManager Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000001008"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/tokenmanager.abi"},"tokenmanager"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CrossChain Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000002000"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://raw.githubusercontent.com/bnb-chain/bsc-genesis-contract/master/abi/crosschain.abi"},"crosschain"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Native Staking Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"0x0000000000000000000000000000000000002001"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/bnb-chain/bsc-genesis-contract/blob/master/abi/staking.abi"},"staking"))))),(0,r.kt)("h2",{id:"on-chain-light-client"},"On-Chain Light Client"),(0,r.kt)("p",null,"The purpose of cross-chain interoperability is to enable one blockchain to function as a light-client of another. Since BNB Beacon Chain is using a classical Byzantine Fault Tolerant consensus algorithm, light-client verification is cheap and easy: all we have to do is check validator signatures on the latest block, and verify a Merkle proof of the state."),(0,r.kt)("p",null,"In Tendermint, validators agree on a block before processing it. This means that the signatures and state root for that block aren't included until the next block. Thus, each block contains a field called LastCommit, which contains the votes responsible for committing the previous block, and a field in the block header called AppHash, which refers to the Merkle root hash of the application after processing the transactions from the previous block. So, if we want to verify the AppHash from height H, we need the signatures from LastCommit at height H+1. (And remember that this AppHash only contains the results from all transactions up to and including block H-1)"),(0,r.kt)("p",null,"Unlike Proof-of-Work, the light-client protocol does not need to download and check all the headers in the blockchain - the client can always jump straight to the latest header available, so long as the validator set has not changed much. If the validator set is changing, the client needs to track these changes, which requires downloading headers for each block in which there is a significant change. Here, we will assume the validator set is constant, and postpone handling validator set changes for another time."),(0,r.kt)("p",null,"Ethereum platform supports stateless precompiled contract implemented with golang and normal contract implemented with solidity. As compared to normal contracts, precompiled contracts are more efficient and costs less gas, but they are stateless. However, on-chain light client must be stateful. So here we will try to a mixed approach: precompiled implemented contract(stateless calculation, such as signature verification) and normal contract (store validator set and trusted appHash)."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img",src:a(47361).Z,width:"646",height:"358"})),(0,r.kt)("h3",{id:"precompile-contract"},"Precompile Contract"),(0,r.kt)("h4",{id:"validate-tendermint-header"},"Validate Tendermint Header"),(0,r.kt)("p",null,"This contract implements tendermint header verification algorithm. The input parameters contain the trusted consensus state and a new tendermint header. The validation algorithm will verify the new tendermint header against the trusted consensus state. If the new header is valid, a new consensus state will be created and returned to caller. Otherwise, an error will be returned."),(0,r.kt)("h4",{id:"validate-merkle-proof"},"Validate Merkle Proof"),(0,r.kt)("p",null,"This contract implements a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-026-general-merkle-proof.md"},"Tendermint merkle proof verification algorithm"),"."),(0,r.kt)("h3",{id:"build-in-system-contract-1"},"Build-in System Contract"),(0,r.kt)("h4",{id:"merkle-proof-verification-library"},(0,r.kt)("strong",{parentName:"h4"},"Merkle Proof Verification Library")),(0,r.kt)("p",null,"This library provides an util to verify merkle proof from BC. Contracts which need to verify Merkle proof just need to import this library."),(0,r.kt)("h4",{id:"tokenhub-contract"},(0,r.kt)("strong",{parentName:"h4"},"TokenHub Contract")),(0,r.kt)("p",null,"This contract focuses on cross chain token transfer."),(0,r.kt)("h4",{id:"tokenmanager-contract"},(0,r.kt)("strong",{parentName:"h4"},"TokenManager Contract")),(0,r.kt)("p",null,"This contract focuses on binding and unbinding tokens on two chains."),(0,r.kt)("h4",{id:"bscvalidatorset-contract"},(0,r.kt)("strong",{parentName:"h4"},"BSCValidatorSet Contract")),(0,r.kt)("p",null,"It is a watcher of validators change of BSC on BNB Beacon Chain. It will interact with light client contracts to verify the interchain transaction, and apply the validator set change for BSC. It also stores rewarded gas fee of blocking for validators, and distribute it to validators when receiving cross chain package of validatorSet change."),(0,r.kt)("h4",{id:"system-reward-contract"},(0,r.kt)("strong",{parentName:"h4"},"System Reward Contract")),(0,r.kt)("p",null,"The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract."),(0,r.kt)("h4",{id:"liveness-slash-contract"},(0,r.kt)("strong",{parentName:"h4"},"Liveness Slash Contract")),(0,r.kt)("p",null,"The liveness of BSC relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators."),(0,r.kt)("h4",{id:"bscvalidatorset-contract-1"},(0,r.kt)("strong",{parentName:"h4"},"BscValidatorSet Contract")),(0,r.kt)("p",null,"This contract focuses on handling staking change package from BC. It also provides the validatorset data query for BSC consensus engine."),(0,r.kt)("h4",{id:"relayerhub-contract"},(0,r.kt)("strong",{parentName:"h4"},"RelayerHub Contract")),(0,r.kt)("p",null,"This contract manages the authority of bsc-relayer. Someone who wants to run a bsc-relayer must call the contract to deposit some BNB to get the authorization."),(0,r.kt)("h4",{id:"governance-contract"},(0,r.kt)("strong",{parentName:"h4"},"Governance Contract")),(0,r.kt)("p",null,"This contract handles the governance package from BC. The governance package contains the target contract address, parameter name and new parameter value. Once the package is verified, this contract will call the parameter update method of the target contract to update the parameter to new value."),(0,r.kt)("h4",{id:"cross-chain-contract"},(0,r.kt)("strong",{parentName:"h4"},"Cross Chain Contract")),(0,r.kt)("p",null,"This contract focuses on cross chain packages pretreatment and sending cross chain packages to BC by emit event. The packages pretreatment includes sequence validation and the merkle proof verification. Once they are passed, the package will be routed to application build-in system contract, such as tokenhub or bscvalidator. Besides, if tokenhub or bscvalidator wants to send packages to BC, they need to encode their packages with rlp and call this contract to send them."))}m.isMDXComponent=!0},47361:(t,e,a)=>{a.d(e,{Z:()=>n});const n=a.p+"assets/images/lightclient-7f313cf3188b6d313659a17c721dd143.png"}}]);